<!DOCTYPE html>
<html lang="en">
<head>
<!-- Apr 25, 2021 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>JWT, JWKS in Web Development</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Frank Zhao">
<link rel='icon' type='image/x-icon' href='/images/favicon.ico'/>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<link rel='stylesheet' href='https://code.cdn.mozilla.net/fonts/fira.css'>
<link rel='stylesheet' href='/css/site.css?v=2' type='text/css'/>
<link rel='stylesheet' href='/css/custom.css' type='text/css'/>
<link rel='stylesheet' href='/css/syntax-coloring.css' type='text/css'/>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../"> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><header id="top" class="status">
<div class="intro">
  <img
    src="/images/Lisplogo_alien_256.png"
    alt="Land of Lisp"
    class="no-border"
  />
  <h1>
    <span class="gray">Zhao</span>
    <span class="black">Wei</span>
  </h1>
  <p>
    How can man die better than facing fearful odds, for the ashes of his
    fathers and the temples of his Gods? -- By Horatius.
  </p>
</div>

<div class="nav">
  <ul>
    <li><a href="/">Posts</a>.</li>
    <li><a href="/about/">About</a>.</li>
  </ul>
</div>
</header>
<main id="content">
<header>
<h1 class="title">JWT, JWKS in Web Development</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org652b922">Introduction</a></li>
<li><a href="#org52d9b3a">Differences between &ldquo;Basic&rdquo; and &ldquo;Bearer&rdquo; in the Authorization header</a>
<ul>
<li><a href="#org6f2e0d0">Basic auth header</a></li>
<li><a href="#orgabf03b6">Bearer auth header</a></li>
</ul>
</li>
<li><a href="#org4e731ad">Basic concepts</a>
<ul>
<li><a href="#orgd43d861">Encryption algorithms</a>
<ul>
<li><a href="#orgfd2ba72">Symmetric encryption</a></li>
<li><a href="#orgbc26e31">Asymmetric encryption</a></li>
<li><a href="#org1b54992">How to generate key-pair</a></li>
</ul>
</li>
<li><a href="#orgd3bf760">JWT and JWKS</a>
<ul>
<li><a href="#org44ec4c0">What is JWT?</a></li>
<li><a href="#org346c4e3">What is JWKS?</a></li>
<li><a href="#org075277c">Load Keys into JWKS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4e1752a">How to generate JWT?</a>
<ul>
<li><a href="#org1c45200">Generate JWT signed with HS256</a></li>
<li><a href="#orgbd8871f">Generate JWT signed with RS256</a>
<ul>
<li><a href="#org41ec395">Sign JWT with RS256</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbffc526">How to verify JWT?</a>
<ul>
<li><a href="#orgac58c9c">Verify JWT with jsonwebtoken package</a>
<ul>
<li><a href="#org5b32ed0">Verify symmetric algorithm JWT</a></li>
<li><a href="#orgce13186">Verify asymmetric algorithm signed JWT</a></li>
</ul>
</li>
<li><a href="#org1ab70de">How to verify JWT using JWKS?</a></li>
<li><a href="#orga9df107">How to verify JWT as middleware in practise.</a></li>
</ul>
</li>
<li><a href="#orga303fa9">General flow to implement JWKS</a></li>
<li><a href="#orge66eeea">Summary</a></li>
<li><a href="#orgeba37ed">References</a></li>
</ul>
</div>
</nav>

<section id="outline-container-org652b922" class="outline-2">
<h2 id="org652b922">Introduction</h2>
<div class="outline-text-2" id="text-org652b922">
<p>
It describes the concepts and steps I learned to use tokens to secure web service, especially for:
</p>
<ul class="org-ul">
<li>Basic Authentication vs what is Bear Authentication</li>
<li>What is JWT and JWKS?</li>
<li>How JWT is used (sign and verify)?</li>
<li>How JWKS is used to verify JWT?</li>
</ul>
</div>
</section>


<section id="outline-container-org52d9b3a" class="outline-2">
<h2 id="org52d9b3a">Differences between &ldquo;Basic&rdquo; and &ldquo;Bearer&rdquo; in the Authorization header</h2>
<div class="outline-text-2" id="text-org52d9b3a">
<p>
In web development, we usually need to configure &ldquo;Authorization&rdquo; header(I will call it auth header for short) before sending the request. If you notice, there are two kinds of auth header, &ldquo;Basic&rdquo; and &ldquo;Bearer&rdquo;.
</p>
</div>

<div id="outline-container-org6f2e0d0" class="outline-3">
<h3 id="org6f2e0d0">Basic auth header</h3>
<div class="outline-text-3" id="text-org6f2e0d0">
<p>
It is usually needed when we request some information from auth-provider. For example, when we want to introspect access-token from oidc-provider. 
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">let</span> <span class="org-variable-name">authHeader</span> = <span class="org-string">'Basic '</span> + Buffer.from(client_id + <span class="org-string">':'</span> + client_secret, <span class="org-string">'utf8'</span>).toString(<span class="org-string">'base64'</span>);
<span class="org-keyword">let</span> <span class="org-variable-name">options</span> = {
  method: <span class="org-string">'POST'</span>  ,
  url: <span class="org-string">`${authUrl}/token/introspection`</span>,
  headers: {Authorization: authHeader},
  form: {
    token: access_token
  }
};
</pre>
</div>
<ul class="org-ul">
<li>Its format: <code>Basic</code> + &ldquo; &rdquo; + base64-encoded string constructed from <code>id(username):password(secret)</code>.</li>
<li>TODO:: <b>Note</b>: base64 is a reversible encoding. Does that means <code>password(secret)</code> is not secured? Does https make it secured?</li>
</ul>
</div>
</div>

<div id="outline-container-orgabf03b6" class="outline-3">
<h3 id="orgabf03b6">Bearer auth header</h3>
<div class="outline-text-3" id="text-orgabf03b6">
<p>
It is needed when we want to request protected resources usually are some service&rsquo;s APIs endpoints. For example, after we got access-token after login, we need to use Bearer token in request&rsquo;s header. 
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">let</span> <span class="org-variable-name">headersOption</span> = {
  <span class="org-string">'Accept'</span>: <span class="org-string">'application/json'</span>,
  <span class="org-string">'Content-Type'</span>: <span class="org-string">'application/json'</span>,
  <span class="org-string">'Authorization'</span>: <span class="org-string">'Bearer '</span> + access_token
};
</pre>
</div>
<ul class="org-ul">
<li>&ldquo;Bearer authorization&rdquo; means &ldquo;give access to the bearer of this token&rdquo;.</li>
<li>No matter whether it is access-token or other kind of token, the bearer token is a encrypted string. It is generated by the auth-provider in response to a login request.</li>
</ul>
</div>
</div>
</section>

<section id="outline-container-org4e731ad" class="outline-2">
<h2 id="org4e731ad">Basic concepts</h2>
<div class="outline-text-2" id="text-org4e731ad">
</div>
<div id="outline-container-orgd43d861" class="outline-3">
<h3 id="orgd43d861">Encryption algorithms</h3>
<div class="outline-text-3" id="text-orgd43d861">
<p>
To make data transfered safely between network, we need to encrypt data we transfered. There are mainly two kinds of algorithms to do this: symmetric encryption and asymmetric encryption.
</p>
</div>

<div id="outline-container-orgfd2ba72" class="outline-4">
<h4 id="orgfd2ba72">Symmetric encryption</h4>
<div class="outline-text-4" id="text-orgfd2ba72">
<p>
Symmetric encryptions use the same key for doing encryption and decryption. 
</p>
<ul class="org-ul">
<li>It is fast to do encryption and decryption, so it is very useful to transmit data.</li>
<li>However, we need to transmit the symmetric encryption key to the receiver side safely. In this case, this secret key becomes the content we need to encrypt. This is the moment we choose to use asymmetric encription.</li>
<li>Common symmetric encryption algorithms include:
<ul class="org-ul">
<li>HS256(HMAC + SHA256)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgbc26e31" class="outline-4">
<h4 id="orgbc26e31">Asymmetric encryption</h4>
<div class="outline-text-4" id="text-orgbc26e31">
<p>
Instead of using the same key to do both encryption and decryption, asymmetric encryption algorithm uses a pair of key: use private key to encrypt data and use publick key to decrypt.
</p>
<ul class="org-ul">
<li>We NEVER share the private key.</li>
<li>We could share publick key safely without concern.</li>
<li>It is much slower than symmetric encryption, so we only use it to transmit curial data.</li>
<li>Common asymmetric encryption algorithms include:
<ul class="org-ul">
<li>RS256(RSASSA-PKCS1-v1<sub>5</sub> + SHA256)</li>
<li>ES256(ECDSA + P-256 + SHA256)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1b54992" class="outline-4">
<h4 id="org1b54992">How to generate key-pair</h4>
<div class="outline-text-4" id="text-org1b54992">
<ul class="org-ul">
<li><p>
To generate key-pair using RS256
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Generate a private key</span>
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048

<span class="org-comment-delimiter"># </span><span class="org-comment">Derive the public key from the private key</span>
openssl rsa -pubout -in private_key.pem -out public_key.pem
</pre>
</div></li>

<li><p>
To generate key-pair using ES256
</p>
<div class="org-src-container">
<pre class="src src-sh"><span class="org-comment-delimiter"># </span><span class="org-comment">Generate a private key (prime256v1 is the name of the parameters used</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">to generate the key, this is the same as P-256 in the JWA spec).</span>
openssl ecparam -name prime256v1 -genkey -noout -out ecdsa_private_key.pem

<span class="org-comment-delimiter"># </span><span class="org-comment">Derive the public key from the private key</span>
openssl ec -in ecdsa_private_key.pem -pubout -out ecdsa_public_key.pem
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd3bf760" class="outline-3">
<h3 id="orgd3bf760">JWT and JWKS</h3>
<div class="outline-text-3" id="text-orgd3bf760">
</div>
<div id="outline-container-org44ec4c0" class="outline-4">
<h4 id="org44ec4c0">What is JWT?</h4>
<div class="outline-text-4" id="text-org44ec4c0">
<p>
JWT(JSON Web Token) encodes a series information(called claims). Those information typically includes:
</p>
<ul class="org-ul">
<li>iss, issuer</li>
<li>sub, subject</li>
<li>aud, audience</li>
<li>exp, expiration</li>
<li>nbf, not before</li>
<li>iat, issued at</li>
</ul>

<p>
Signing is a cryptographic operation that generates a “signature” (part of the JWT), later the recipient of the token can validate to ensure that the token has not been tampered with.
</p>

<p>
We usually use middleware in web service to verify the signed JWT passed from Authorization header. For example, <code>access_token</code> got from auth-provider usually contains the scopes/permissions, and middleware uses that to protect API endpoint.
</p>
</div>
</div>


<div id="outline-container-org346c4e3" class="outline-4">
<h4 id="org346c4e3">What is JWKS?</h4>
<div class="outline-text-4" id="text-org346c4e3">
<p>
The JSON Web Key Set (JWKS) is a set of keys containing the <b>public keys</b> used to <b>verify any JSON Web Token (JWT)</b> issued by the authorization server and signed using the RS256(RSA Signature with SHA-256) algorithm.
</p>
</div>
</div>

<div id="outline-container-org075277c" class="outline-4">
<h4 id="org075277c">Load Keys into JWKS</h4>
<div class="outline-text-4" id="text-org075277c">
<p>
We could use package <code>node-jose</code> to load keys (public or private) files as JWK.
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">function</span> <span class="org-function-name">readJWKFromPEM</span>(<span class="org-variable-name">filename</span>) {
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">Promise</span>((resolve, reject)=&gt; {
    <span class="org-keyword">const</span> <span class="org-variable-name">key</span> = fs.readFileSync(filename);
    <span class="org-keyword">const</span> <span class="org-variable-name">keystore</span> = jose.JWK.createKeyStore();
    keystore.add(key, <span class="org-string">'pem'</span>).then(()=&gt;{
      <span class="org-keyword">const</span> <span class="org-variable-name">jwks</span> = keystore.toJSON(<span class="org-constant">true</span>);
      resolve(jwks);
    }).<span class="org-keyword">catch</span>(err=&gt;{
      console.log(<span class="org-string">"add JWK failed from PEM key:"</span>, err.message);
      reject(err);
    });
  });
}
</pre>
</div>
</div>
</div>
</div>
</section>

<section id="outline-container-org4e1752a" class="outline-2">
<h2 id="org4e1752a">How to generate JWT?</h2>
<div class="outline-text-2" id="text-org4e1752a">
<p>
A signed JWT consists of three parts: header, payload and signature seperated by &ldquo;.&rdquo;:
</p>

<p>
Header specifies the algorithm used and the type 
</p>
<div class="org-src-container">
<pre class="src src-json">{
  <span class="org-keyword">"alg"</span>: <span class="org-string">"HS256"</span>,
  <span class="org-keyword">"typ"</span>: <span class="org-string">"JWT"</span>
}
</pre>
</div>

<p>
Payload contains the claims
</p>
<div class="org-src-container">
<pre class="src src-json">{
  <span class="org-keyword">"sub"</span>: <span class="org-string">"1234567890"</span>,
  <span class="org-keyword">"name"</span>: <span class="org-string">"John Doe"</span>,
  <span class="org-keyword">"manager"</span>: <span class="org-constant">true</span>
}
</pre>
</div>

<p>
And signature is composed from the signing of encoded header and encoded payload with a secret. See below about how to generate JWT with different algorithms.
</p>
</div>

<div id="outline-container-org1c45200" class="outline-3">
<h3 id="org1c45200">Generate JWT signed with HS256</h3>
<div class="outline-text-3" id="text-org1c45200">
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">const</span> <span class="org-variable-name">encodedHeader</span> = base64(utf8(JSON.stringify(header)));
<span class="org-keyword">const</span> <span class="org-variable-name">encodedPayload</span> = base64(utf8(JSON.stringify(payload)));
<span class="org-keyword">const</span> <span class="org-variable-name">signature</span> = base64(hmac(<span class="org-string">`${encodedHeader}.${encodedPayload}`</span>,secret, sha256));
<span class="org-keyword">const</span> <span class="org-variable-name">jwt</span> = <span class="org-string">`${encodedHeader}.${encodedPayload}.${signature}`</span>;
</pre>
</div>

<p>
If we use <code>jsonwebtoken</code> npm package, this could be simplified as:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">jwt</span> = require(<span class="org-string">'jsonwebtoken'</span>);

<span class="org-keyword">const</span> <span class="org-variable-name">payload</span> = {
  sub: <span class="org-string">"1234567890"</span>,
  name: <span class="org-string">"John Doe"</span>,
  manager: <span class="org-constant">true</span>
};

<span class="org-keyword">const</span> <span class="org-variable-name">secretKey</span> = <span class="org-string">'secret'</span>;

<span class="org-keyword">const</span> <span class="org-variable-name">token</span> = jwt.sign(payload, secretKey, {
    algorithm: <span class="org-string">'HS256'</span>,
    expiresIn: <span class="org-string">'10m'</span> <span class="org-comment-delimiter">// </span><span class="org-comment">if ommited, the token will not expire</span>
});

<span class="org-keyword">var</span> <span class="org-variable-name">decoded</span> = jwt.verify(token, secretKey);
</pre>
</div>
<p>
<b>Warning</b>: <a href="https://tools.ietf.org/html/rfc7518#page-7">JSON Web Algorithms RFC 7518</a> states that a key of the same size as the hash output (for instance, 256 bits for &ldquo;HS256&rdquo;) or larger <b>MUST</b> be used with the HS256 algorithm. One character is 8-bits, so we need to use at least 32 character and more as secret key for signing with HS256.
</p>
</div>
</div>

<div id="outline-container-orgbd8871f" class="outline-3">
<h3 id="orgbd8871f">Generate JWT signed with RS256</h3>
<div class="outline-text-3" id="text-orgbd8871f">
<p>
After we <a href="#org1b54992">generate key-pair</a>, we use private-key to sign and public-key to verify it.
</p>
</div>
<div id="outline-container-org41ec395" class="outline-4">
<h4 id="org41ec395">Sign JWT with RS256</h4>
<div class="outline-text-4" id="text-org41ec395">
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">const</span> <span class="org-variable-name">encodedHeader</span> = base64(utf8(JSON.stringify(header)));
<span class="org-keyword">const</span> <span class="org-variable-name">encodedPayload</span> = base64(utf8(JSON.stringify(payload)));
<span class="org-keyword">const</span> <span class="org-variable-name">signature</span> = base64(rsassa(<span class="org-string">`${encodedHeader}.${encodedPayload}`</span>, privateKey, sha256));
<span class="org-keyword">const</span> <span class="org-variable-name">jwt</span> = <span class="org-string">`${encodedHeader}.${encodedPayload}.${signature}`</span>;
</pre>
</div>

<p>
If we use <code>jsonwebtoken</code> to do it:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">async</span> <span class="org-keyword">function</span> generateJWT(<span class="org-variable-name">payload</span>, <span class="org-variable-name">privateKeyName</span>) {
  <span class="org-keyword">let</span> <span class="org-variable-name">privateKey</span> = fs.readFileSync(privateKeyName);
  <span class="org-keyword">let</span> <span class="org-variable-name">jwks</span> = <span class="org-keyword">await</span> readJWKFromPEM(privateKeyName);
  <span class="org-keyword">const</span> <span class="org-variable-name">signed</span> = jwt.sign(payload, privateKey, {
    algorithm: <span class="org-string">'RS256'</span>,
    expiresIn: <span class="org-string">'24h'</span>,
    keyid: jwks.keys[0].kid
    issuer: process.env.issuer
  });

  <span class="org-keyword">return</span> signed;
}
</pre>
</div>
<p>
To sign JWT with ES256, change &ldquo;algorithm&rdquo; to &ldquo;ES256&rdquo;.
</p>
</div>
</div>
</div>
</section>


<section id="outline-container-orgbffc526" class="outline-2">
<h2 id="orgbffc526">How to verify JWT?</h2>
<div class="outline-text-2" id="text-orgbffc526">
</div>
<div id="outline-container-orgac58c9c" class="outline-3">
<h3 id="orgac58c9c">Verify JWT with jsonwebtoken package</h3>
<div class="outline-text-3" id="text-orgac58c9c">
</div>
<div id="outline-container-org5b32ed0" class="outline-4">
<h4 id="org5b32ed0">Verify symmetric algorithm JWT</h4>
<div class="outline-text-4" id="text-org5b32ed0">
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">var</span> <span class="org-variable-name">decoded</span> = jwt.verify(token, secretKey);
</pre>
</div>
</div>
</div>
<div id="outline-container-orgce13186" class="outline-4">
<h4 id="orgce13186">Verify asymmetric algorithm signed JWT</h4>
<div class="outline-text-4" id="text-orgce13186">
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">const</span> <span class="org-variable-name">publicRsaKey</span> = <span class="org-string">`&lt;YOUR-PUBLIC-RSA-KEY&gt;`</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">For RS256</span>
<span class="org-keyword">const</span> <span class="org-variable-name">decoded</span> = jwt.verify(signed, publicRsaKey, {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Never forget to make this explicit to prevent</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">signature stripping attacks.</span>
  algorithms: [<span class="org-string">'RS256'</span>],
});

<span class="org-comment-delimiter">// </span><span class="org-comment">For ES256</span>
<span class="org-keyword">const</span> <span class="org-variable-name">decoded</span> = jwt.verify(signed, publicEcdsaKey, {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Never forget to make this explicit to prevent</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">signature stripping attacks.</span>
    algorithms: [<span class="org-string">'ES256'</span>],
});
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1ab70de" class="outline-3">
<h3 id="org1ab70de">How to verify JWT using JWKS?</h3>
<div class="outline-text-3" id="text-org1ab70de">
<p>
JWKS stores an array of public-keys in the format of JWK(See <a href="https://tools.ietf.org/html/rfc7517">RFC 7517</a>). So, we need to find the matching public-key using <code>kid</code> property from JWT&rsquo;s header.
</p>

<p>
Suppose we have a priviate-key: <code>priviate_key.pem</code> <a href="#org1b54992">generated with RS256</a>. Let&rsquo;s generate JWT from it.
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">let</span> <span class="org-variable-name">signedJWT</span> = <span class="org-keyword">await</span> generateJWT({
  first_name: <span class="org-string">"Zhao"</span>,
  last_name: <span class="org-string">"Wei"</span>
}, <span class="org-string">"private_key.pem"</span>);


console.log(<span class="org-string">"&gt;&gt; decoded JWT:"</span>);
<span class="org-keyword">let</span> <span class="org-variable-name">decodedToken</span> = jwt.decode(signedJWT, {complete: <span class="org-constant">true</span>});
console.log(decodedToken);
</pre>
</div>

<p>
Its output look like this:
</p>
<div class="org-src-container">
<pre class="src src-text">&gt;&gt; signed JWT:
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Im41SkNCY2dhUVJFeW1tb3pvcDJvYnBtalZQeUZ2aHR3UkZFY3RSdDFCeWsifQ.eyJmaXJzdF9uYW1lIjoiWmhhbyIsImxhc3RfbmFtZSI6IldlaSIsImlhdCI6MTYxOTM1NTU4MywiZXhwIjoxNjE5NDQxOTgzfQ.U06ryukF5ywMelTKYbroLnxn62bKQ683i-ty86BQeMZQuXtB5o8CzLXtOM-oW1TYv_Trpzy2EXkPhLE5YpGUwsLxPd9qCKeqMYd7Vm54v2okmfJADVndm4NL5oXHErdaSh1nL4-fkmCXL63zLsH9Sai2QkkIgOwXYAfpz4VcxatMJsLJAl3YGqgrZkKfeQvAJuOb6LXI6Uu9LZD-oGlfJR7VJCtGf4HbdTTU4DBZuIeCQ26u2EkldhW27T9pxI2_D7PVDNikkcu50Rv5s4UHql6RxCRbpHoCOVgrA9sILnlCqT6r78UkgUNrGQidTs-UOAq3DDeuJ19RZBU20xlUgw
</pre>
</div>

<p>
The general steps to verify this token from JWKS:
</p>
<ol class="org-ol">
<li>Retrieve the JWKS and filter for potential signature verification keys.</li>
<li>Decode the JWT and grab the <code>kid</code> property. It is used to lookup the appropriate public-key, as it is also included in the JWT JOSE(Javascript Object Signing and Encryption) hader.</li>
<li>Find the signature verification key in the filtered JWKS with a matching kid property.</li>
<li>Using the x5c property build a certificate which will be used to verify the JWT signature.</li>
<li>Ensure the JWT contains the expected audience, issuer, expiration, etc.</li>
</ol>


<p>
The potential signature verification keys means each key from &ldquo;keys&rdquo; member of JWKS should contains the following property:
</p>
<ul class="org-ul">
<li><code>kid</code>, is used to identify a key.</li>
<li><code>kty</code>, is used to identify the cryptographic algorithm family used with the key.</li>
<li><code>use</code>, is used to indentify the use of the public key. Values could be: <code>sig</code> (signature), <code>enc</code> (encryption)</li>
<li><code>exp</code>, is used to define the expiration time for the given JWK.</li>
<li><code>kid</code>, is the unique identifier for the key.</li>
<li><code>n</code>, contains the modulus value for the RSA public key.  It is represented as a Base64urlUInt-encoded value. (see <a href="https://tools.ietf.org/html/rfc7518#section-6.3">https://tools.ietf.org/html/rfc7518#section-6.3</a>)</li>
<li><code>e</code>, contains the exponent value for the RSA public key.  It is represented as a Base64urlUInt-encoded value.</li>
</ul>

<p>
Suppose the public key stored in JWKS is something like:
</p>
<div class="org-src-container">
<pre class="src src-json">{
  kty: 'RSA',
  kid: 'n<span class="org-constant">5</span>JCBcgaQREymmozop<span class="org-constant">2</span>obpmjVPyFvhtwRFEctRt<span class="org-constant">1</span>Byk',
  n: '<span class="org-constant">0</span>HWDCPjBAniQkcc<span class="org-constant">0</span>UqcMH<span class="org-constant">4</span>ZMYcrU<span class="org-constant">3</span>xnya<span class="org-constant">9</span>Bkjz<span class="org-constant">4</span>Ev<span class="org-constant">6</span>Ohj_Ff-xNnmQKvJKu<span class="org-constant">3</span>x<span class="org-constant">9</span>RzZJW<span class="org-constant">6</span>vPzVOjQRTvBqT<span class="org-constant">4</span>I<span class="org-constant">3</span>KkrUb<span class="org-constant">5</span>XVr<span class="org-constant">4</span>L_WEpXOX<span class="org-constant">2</span>JpCQlI<span class="org-constant">1</span>RdmPDUKyoMO_rGa<span class="org-constant">5</span>VoAFrj<span class="org-constant">4</span>txGLXxELw<span class="org-constant">4</span>_s<span class="org-constant">2</span>azKgjx<span class="org-constant">0</span>Wx<span class="org-constant">7</span>FbQLlMhLR<span class="org-constant">0</span>c<span class="org-constant">7</span>XzK<span class="org-constant">7</span>q<span class="org-constant">1</span>PUjBehA<span class="org-constant">4</span>_FEtUsKwFexfiXJGeryQTo<span class="org-constant">3</span>ftXmwpNf<span class="org-constant">785</span>aSZxsopuimlh<span class="org-constant">8</span>iYVvP<span class="org-constant">4</span>utI<span class="org-constant">9</span>R<span class="org-constant">0</span>c<span class="org-constant">8</span>jrIhYJ<span class="org-constant">9</span>Ijfzrv<span class="org-constant">23</span>bslf<span class="org-constant">4</span>BH-tmsEpXPxOPjdRfaJamtSrJfCtW<span class="org-constant">7</span>ZdkwDCgWt<span class="org-constant">1</span>HsrlP_p<span class="org-constant">46</span>mGMUmvqqnwG<span class="org-constant">2</span>eyDjg<span class="org-constant">29</span>eJoiu<span class="org-constant">5</span>-tKYQ',
  e: 'AQAB'
}
</pre>
</div>
<p>
Usually, there are multiple such JWKs. So, we will need to use the <code>kid</code> property to find the exect key necessary to verify the JWT.
</p>


<p>
We could decode the JWT as it is simply base64 url encoded. Here, we decode the JWT with <code>jwt_decode</code>, the decoded JWT signed from above is:
</p>
<div class="org-src-container">
<pre class="src src-json">{
  header: {
    alg: 'RS<span class="org-constant">256</span>',
    typ: 'JWT',
    kid: 'n<span class="org-constant">5</span>JCBcgaQREymmozop<span class="org-constant">2</span>obpmjVPyFvhtwRFEctRt<span class="org-constant">1</span>Byk'
  },
  payload: {
    first_name: 'Zhao',
    last_name: 'Wei',
    iat: <span class="org-constant">1619355693</span>,
    exp: <span class="org-constant">1619442093</span>
  },
  signature: 'OwijTq<span class="org-constant">7</span>lmwumcBc_srwWh<span class="org-constant">53</span>Yr<span class="org-constant">5</span>_lBHsELmKUO<span class="org-constant">5</span>m<span class="org-constant">22</span>nANoIlu-xVGD<span class="org-constant">7</span>dOw<span class="org-constant">0</span>K_JKXiLgiZV<span class="org-constant">0</span>qyJF<span class="org-constant">2</span>zU<span class="org-constant">1</span>G<span class="org-constant">4</span>fLJw<span class="org-constant">7</span>w<span class="org-constant">21</span>SO<span class="org-constant">8</span>s<span class="org-constant">78430</span>SFAmbKLYM<span class="org-constant">2</span>yTVBYKs<span class="org-constant">76</span>nRpyzAw<span class="org-constant">4188</span>DmEcXv<span class="org-constant">7</span>hb<span class="org-constant">4</span>f-<span class="org-constant">58</span>ANkdKUJ<span class="org-constant">4</span>MeFgHFD<span class="org-constant">8</span>wIB<span class="org-constant">8</span>aSA<span class="org-constant">5</span>CUxcCyEy<span class="org-constant">54</span>sNetQo_PZmrDFgfVjYHDszRG<span class="org-constant">4</span>oFmwtukxvu<span class="org-constant">7</span>ySr<span class="org-constant">2</span>SReuvboop_uw<span class="org-constant">9</span>sPvS<span class="org-constant">7</span>mcy<span class="org-constant">4</span>plLEqjHltH_QL<span class="org-constant">7</span>awdFyxEg<span class="org-constant">3</span>mC<span class="org-constant">4</span>SoIcPSDdRcs<span class="org-constant">5</span>Co<span class="org-constant">1</span>GS-Y-ZbORS<span class="org-constant">65</span>zIQlNufSD<span class="org-constant">7</span>SQyIqIVzxF<span class="org-constant">60</span>ZNCPS<span class="org-constant">1</span>SyG-QFT<span class="org-constant">7</span>kj-_PpdYg<span class="org-constant">29</span>hA<span class="org-constant">2</span>Ng'
}
</pre>
</div>

<p>
Now, we have find the matching JWK using <code>kid</code> (assuming there are multiple public keys in JWKS). We could verify the JWT with the JWK now.
</p>
<ol class="org-ol">
<li>Convert JWK to PEM using <a href="https://github.com/Brightspace/node-jwk-to-pem#readme">jwk-to-pem</a>.</li>
<li>Verify signed JWT token using <code>jwt</code>.</li>
</ol>
<p>
The simple code could look like:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">let</span> <span class="org-variable-name">publicPem</span> = jwkToPem(publicJWK);
jwt.verify(signedJWT, publicPem);
</pre>
</div>
<p>
That is it. We verify signed JWT with matched public-key.
</p>
</div>
</div>


<div id="outline-container-orga9df107" class="outline-3">
<h3 id="orga9df107">How to verify JWT as middleware in practise.</h3>
<div class="outline-text-3" id="text-orga9df107">
<p>
The above section illustrates how to verify signed JWT from multiple public keys as JWKS step by step. In practise, Auth-provider usually provide an endpoint <code>/keys</code> for GET requests which returns a list of keys.    
</p>
<div class="org-src-container">
<pre class="src src-text">curl https://&lt;some_auth_provider&gt;/keys |jq
  ...
{
  "keys": [
    public-key-01-in-JWK-format,
    public-key-02-in-JWK-format,
    ...
  ]
}
</pre>
</div>

<p>
And the middleware which validate JWT could use <code>jwks-rsa</code> and <code>express-jwt</code> to do above operations automatically:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-keyword">import</span> express, { Request, Response } from <span class="org-string">'express'</span>;
<span class="org-keyword">import</span> { issuer } from <span class="org-string">'./config'</span>;
<span class="org-keyword">import</span> jwt from <span class="org-string">'express-jwt'</span>;
<span class="org-keyword">import</span> jwksRsa from <span class="org-string">'jwks-rsa'</span>;

<span class="org-keyword">const</span> <span class="org-variable-name">checkJwt</span> = jwt({
    secret: jwksRsa.expressJwtSecret({
        cache: <span class="org-constant">true</span>,
        rateLimit: <span class="org-constant">true</span>,
        jwksRequestsPerMinute: 5,
        jwksUri: <span class="org-string">`http://localhost:3344/keys`</span>
    }),
    issuer,
    algorithms: [<span class="org-string">'RS256'</span>],
    requestProperty: <span class="org-string">'tokenData'</span>
});

<span class="org-keyword">const</span> <span class="org-variable-name">app</span> = express()
app.use(<span class="org-string">'/some-api'</span>, checkJwt, (req: Request, res: Response) =&gt; {
    res.send(<span class="org-string">`Result: ${JSON.stringify(req.tokenData)}`</span>);
})

app.listen(2233, () =&gt; console.log(<span class="org-string">`Backend is running on port 2233`</span>))
</pre>
</div>
</div>
</div>
</section>

<section id="outline-container-orga303fa9" class="outline-2">
<h2 id="orga303fa9">General flow to implement JWKS</h2>
<div class="outline-text-2" id="text-orga303fa9">

<figure id="org1911d52">
<img src="general_flow_to_implement_JWKS.png" alt="general_flow_to_implement_JWKS.png">

</figure>

<p>
The important steps involve with JWKS are:
</p>
<ul class="org-ul">
<li>Decode the JOSE header in order to find the JWK kid.</li>
<li>Retrieve the list of avaiable public keys.</li>
<li>Filter the key with matching kid.</li>
<li>Verify JWT with public key.</li>
</ul>
</div>
</section>

<section id="outline-container-orge66eeea" class="outline-2">
<h2 id="orge66eeea">Summary</h2>
<div class="outline-text-2" id="text-orge66eeea">
<ul class="org-ul">
<li>When we need to use HS256 to sign JWT, the secret length should not be shorter than 32 characters.</li>
<li>We better to use asymmetric algorithm to sign our JWT.</li>
<li>We use private key to sign JWT and use publick key to verify JWT.</li>
<li>JWKS stores array of <b>public-key</b> use to verify JWT.</li>
</ul>
</div>
</section>

<section id="outline-container-orgeba37ed" class="outline-2">
<h2 id="orgeba37ed">References</h2>
<div class="outline-text-2" id="text-orgeba37ed">
<ul class="org-ul">
<li><a href="https://tools.ietf.org/html/rfc7517">RFC 7517 &#x2013; JSON Web Key (JWK)</a></li>
<li><a href="https://tools.ietf.org/html/rfc7518">RFC 7518 &#x2013; JSON Web Algorithms (JWA)</a></li>
<li><a href="https://auth0.com/blog/navigating-rs256-and-jwks/">Navigating RS256 and JWKS</a></li>
<li><a href="https://omakoleg.gitlab.io/node-jwt-guide/">Typescript Node.js guide for JWT signing and verifying using asymmetric keys</a></li>
<li><a href="https://auth0.com/blog/brute-forcing-hs256-is-possible-the-importance-of-using-strong-keys-to-sign-jwts/#Structure-of-a-JSON-Web-Token">Brute Forcing HS256 is Possible: The Importance of Using Strong Keys in Signing JWTs</a></li>
<li><a href="https://blog.unosquare.com/why-and-how-to-improve-jwt-security-with-jwks-key-rotation-in-java">Why and how to improve JWT securty with JWKS key rotation in JAVA</a></li>
<li><a href="https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3">JWT, JWS and JWE for Not So Dummies! (Part I)</a></li>
</ul>
</div>
</section>
</main>
<footer id="postamble" class="status">
<div class='footer'>
  Copyright © 2020 <a href='mailto:hyperion_z@outlook.com'>Zhao Wei.</a><br>
  Inspired by <a href='https://nicolas.petton.fr'>https://nicolas.petton.fr</a> <br>
  Last updated on Apr 25, 2021. Generated using <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.0.91 (<a href="https://orgmode.org">Org</a> mode 9.4.5).
</div>
</footer>
</body>
</html>
